'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.isNetworkError = isNetworkError;
exports.isRetryableError = isRetryableError;
exports.isSafeRequestError = isSafeRequestError;
exports.isIdempotentRequestError = isIdempotentRequestError;
exports.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
exports.exponentialDelay = exponentialDelay;
exports.default = axiosRetry;

var _isRetryAllowed = require('is-retry-allowed');

var _isRetryAllowed2 = _interopRequireDefault(_isRetryAllowed);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _fastSafeStringify = require('fast-safe-stringify');

var _fastSafeStringify2 = _interopRequireDefault(_fastSafeStringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CancelToken = _axios2.default.CancelToken;

var namespace = 'axios-retry';

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkError(error) {
  var _ref = error.config || {},
      _ref$qwestLegacy = _ref.qwestLegacy,
      qwestLegacy = _ref$qwestLegacy === undefined ? false : _ref$qwestLegacy;

  return !error.response && Boolean(error.code) && ( // Prevents retrying cancelled requests
  error.code !== 'ECONNABORTED' || !!qwestLegacy) && // Prevents retrying timed out requests
  (0, _isRetryAllowed2.default)(error); // Prevents retrying unsafe errors
}

var SAFE_HTTP_METHODS = ['get', 'head', 'options'];
var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isRetryableError(error) {
  return error.code !== 'ECONNABORTED' && (!error.response || error.response.status >= 500 && error.response.status <= 599);
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isSafeRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isIdempotentRequestError(error) {
  if (!error.config) {
    // Cannot determine if the request can be retried
    return false;
  }

  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
}

/**
 * @param  {Error}  error
 * @return {boolean}
 */
function isNetworkOrIdempotentRequestError(error) {
  return isNetworkError(error) || isIdempotentRequestError(error);
}

/**
 * @return {number} - delay in milliseconds, always 0
 */
function noDelay() {
  return 0;
}

/**
 * @param  {number} [retryNumber=0]
 * @return {number} - delay in milliseconds
 */
function exponentialDelay() {
  var retryNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  var delay = Math.pow(2, retryNumber) * 100;
  var randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay
  return delay + randomSum;
}

/**
 * Initializes and returns the retry state for the given request/config
 * @param  {AxiosRequestConfig} config
 * @return {Object}
 */
function getCurrentState(config) {
  var currentState = config[namespace] || {};
  currentState.retryCount = currentState.retryCount || 0;
  currentState.requests = currentState.requests || [];
  currentState.cancelled = 'cancelled' in currentState ? currentState.cancelled : false;
  currentState.response = 'response' in currentState ? currentState.response : null;

  config[namespace] = currentState;
  return currentState;
}

/**
 * Returns the axios-retry options for the current request
 * @param  {AxiosRequestConfig} config
 * @param  {AxiosRetryConfig} defaultOptions
 * @return {AxiosRetryConfig}
 */
function getRequestOptions(config, defaultOptions) {
  return Object.assign({}, defaultOptions, config[namespace]);
}

/**
 * @param  {Axios} axios
 * @param  {AxiosRequestConfig} config
 */
function fixConfig(axios, config) {
  if (axios.defaults.agent === config.agent) {
    delete config.agent;
  }
  if (axios.defaults.httpAgent === config.httpAgent) {
    delete config.httpAgent;
  }
  if (axios.defaults.httpsAgent === config.httpsAgent) {
    delete config.httpsAgent;
  }
}

function createCancelToken() {
  var cancelSource = CancelToken.source();
  return {
    cancelSource: cancelSource,
    cancelToken: cancelSource.token
  };
}

function removeCircular(obj) {
  if (obj) {
    return JSON.parse((0, _fastSafeStringify2.default)(obj));
  }
  return obj;
}

function cleanupOutput(output) {
  var keys = Object.keys(output);
  keys.forEach(function (key) {
    output[key] = removeCircular(output[key]);
  });
  return output;
}

/**
 * Adds response interceptors to an axios instance to retry requests failed due to network issues
 *
 * @example
 *
 * import axios from 'axios';
 *
 * axiosRetry(axios, { retries: 3 });
 *
 * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Exponential back-off retry delay between requests
 * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});
 *
 * // Custom retry delay
 * axiosRetry(axios, { retryDelay : (retryCount) => {
 *   return retryCount * 1000;
 * }});
 *
 * // Also works with custom axios instances
 * const client = axios.create({ baseURL: 'http://example.com' });
 * axiosRetry(client, { retries: 3 });
 *
 * client.get('/test') // The first request fails and the second returns 'ok'
 *   .then(result => {
 *     result.data; // 'ok'
 *   });
 *
 * // Allows request-specific configuration
 * client
 *   .get('/test', {
 *     'axios-retry': {
 *       retries: 0
 *     }
 *   })
 *   .catch(error => { // The first request fails
 *     error !== undefined
 *   });
 *
 * @param {Axios} axios An axios instance (the axios object or one created from axios.create)
 * @param {Object} [defaultOptions]
 * @param {number} [defaultOptions.retries=3] Number of retries
 * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]
 *        A function to determine if the error can be retried
 * @param {Function} [defaultOptions.retryDelay=noDelay]
 *        A function to determine the delay between retry requests
 * @return {undefined}
 */
function axiosRetry(axios, defaultOptions) {
  var cancelAll = function cancelAll(config) {
    var currentState = getCurrentState(config);

    currentState.cancelled = true;

    var requests = currentState.requests;


    requests.forEach(function (request) {
      request.preventRetryFromTimeout = true;
      request.preventRetryFromError = true;
    });

    if (config.cancelSource) {
      config.cancelSource.cancel({ config: config });
    }
  };

  var retry = function retry(config) {
    var request = axios(_extends({}, config));
    request.catch(function () {});

    return request;
  };

  axios.interceptors.request.use(function (config) {
    var currentState = getCurrentState(config);
    currentState.lastRequestTime = Date.now();

    var retryTimeout = config.retryTimeout,
        cancelToken = config.cancelToken;


    var curConfig = _extends({}, config);

    if (!cancelToken) {
      curConfig = _extends({}, curConfig, createCancelToken());
    }

    var _getRequestOptions = getRequestOptions(config, defaultOptions),
        _getRequestOptions$qw = _getRequestOptions.qwestLegacy,
        qwestLegacy = _getRequestOptions$qw === undefined ? false : _getRequestOptions$qw;

    curConfig = _extends({}, curConfig, {
      qwestLegacy: qwestLegacy,
      preventRetryFromTimeout: false,
      preventRetryFromError: false,
      hasRetriedFromTimeout: false,
      hasRetriedFromError: false,
      retryFromTimeout: null
    });

    if (retryTimeout) {
      setTimeout(function () {
        if (!curConfig.preventRetryFromTimeout) {
          curConfig.preventRetryFromError = true;
          curConfig.hasRetriedFromTimeout = true;

          curConfig.retryFromTimeout = retry(_extends({}, curConfig));
        }
      }, retryTimeout);
    }

    currentState.requests.push(curConfig);

    return curConfig;
  });

  // In case of success
  axios.interceptors.response.use(function (response) {
    var returnValue = Promise.resolve(response);

    var config = response.config;

    if (!config) return returnValue;

    var currentState = getCurrentState(config);
    if (!currentState) return returnValue;

    currentState.response = response;

    // cancel all pending requests
    cancelAll(config);

    return returnValue;
  }, function (error) {
    // In case of error

    var isCancellation = error.__CANCEL__;
    var config = isCancellation && error.message && error.message.config ? error.message.config : error.config;

    // If we have no information to retry the request
    if (!config) {
      return Promise.reject(cleanupOutput(error));
    }

    var currentState = getCurrentState(config);

    if (currentState && currentState.response) {
      return Promise.resolve(currentState.response);
    }

    var _getRequestOptions2 = getRequestOptions(config, defaultOptions),
        _getRequestOptions2$r = _getRequestOptions2.retries,
        retries = _getRequestOptions2$r === undefined ? 3 : _getRequestOptions2$r,
        _getRequestOptions2$r2 = _getRequestOptions2.retryCondition,
        retryCondition = _getRequestOptions2$r2 === undefined ? isNetworkOrIdempotentRequestError : _getRequestOptions2$r2,
        _getRequestOptions2$r3 = _getRequestOptions2.retryDelay,
        retryDelay = _getRequestOptions2$r3 === undefined ? noDelay : _getRequestOptions2$r3,
        _getRequestOptions2$q = _getRequestOptions2.qwestLegacy,
        qwestLegacy = _getRequestOptions2$q === undefined ? false : _getRequestOptions2$q;

    var retryMeetsCondition = retryCondition(error);
    var shouldRetry = retryMeetsCondition && currentState.retryCount < retries && (!config.hasTimedOut || qwestLegacy) && !config.preventRetryFromError;

    config.preventRetryFromTimeout = true;

    if (shouldRetry) {
      currentState.retryCount++;
      var delay = retryDelay(currentState.retryCount, error);

      // Axios fails merging this configuration to the default configuration because it has an issue
      // with circular structures: https://github.com/mzabriskie/axios/issues/370
      fixConfig(axios, config);

      if (!qwestLegacy && config.timeout && currentState.lastRequestTime) {
        var lastRequestDuration = Date.now() - currentState.lastRequestTime;
        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)
        config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);
        if (config.timeout === 1) {
          config.hasTimedOut = true;
        }
      }

      return new Promise(function (resolve, reject) {
        setTimeout(function () {
          // retries if it should continue with retrying from error
          if (!config.preventRetryFromError) {
            config.hasRetriedFromError = true;
            config.preventRetryFromTimeout = true;
            return retry(config).then(function (result) {
              resolve(result);
            }).catch(function (e) {
              reject(cleanupOutput(e));
            });
          } else if (config.hasRetriedFromTimeout) {
            // if in this meantime (i.e. the delay from retrying from error)
            // the retry from timeout has been dispatched, return that
            // instead and avoid retrying
            return config.retryFromTimeout.then(function (result) {
              return resolve(result);
            }).catch(function (e) {
              reject(cleanupOutput(e));
            });
          }
        }, delay);
      });
      // if it still can retry, but retry from error has been prevented,
      // and it has retried from timeout
    } else if (retryMeetsCondition && !config.hasTimedOut && config.hasRetriedFromTimeout) {
      return config.retryFromTimeout;
    }

    // reject if can't retry anymore
    return Promise.reject(cleanupOutput(error));
  });
}

// Compatibility with CommonJS
axiosRetry.isNetworkError = isNetworkError;
axiosRetry.isSafeRequestError = isSafeRequestError;
axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
axiosRetry.exponentialDelay = exponentialDelay;
//# sourceMappingURL=index.js.map