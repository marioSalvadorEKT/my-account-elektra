{"version":3,"sources":["../es/index.js"],"names":["isNetworkError","isRetryableError","isSafeRequestError","isIdempotentRequestError","isNetworkOrIdempotentRequestError","exponentialDelay","axiosRetry","CancelToken","namespace","error","config","qwestLegacy","response","Boolean","code","SAFE_HTTP_METHODS","IDEMPOTENT_HTTP_METHODS","concat","status","indexOf","method","noDelay","retryNumber","delay","Math","pow","randomSum","random","getCurrentState","currentState","retryCount","requests","cancelled","getRequestOptions","defaultOptions","Object","assign","fixConfig","axios","defaults","agent","httpAgent","httpsAgent","createCancelToken","cancelSource","source","cancelToken","token","removeCircular","obj","JSON","parse","cleanupOutput","output","keys","forEach","key","cancelAll","request","preventRetryFromTimeout","preventRetryFromError","cancel","retry","catch","interceptors","use","lastRequestTime","Date","now","retryTimeout","curConfig","hasRetriedFromTimeout","hasRetriedFromError","retryFromTimeout","setTimeout","push","returnValue","Promise","resolve","isCancellation","__CANCEL__","message","reject","retries","retryCondition","retryDelay","retryMeetsCondition","shouldRetry","hasTimedOut","timeout","lastRequestDuration","max","then","result","e"],"mappings":"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","file":"index.js","sourcesContent":["import isRetryAllowed from 'is-retry-allowed'\nimport axiosLib from 'axios'\nimport safeStringify from 'fast-safe-stringify'\n\nconst CancelToken = axiosLib.CancelToken\n\nconst namespace = 'axios-retry'\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkError(error) {\n  const {\n    qwestLegacy = false,\n  } = error.config || {}\n\n  return !error.response &&\n    Boolean(error.code) && // Prevents retrying cancelled requests\n    (\n      error.code !== 'ECONNABORTED' || !!qwestLegacy\n    ) && // Prevents retrying timed out requests\n    isRetryAllowed(error) // Prevents retrying unsafe errors\n}\n\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options']\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete'])\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isRetryableError(error) {\n  return error.code !== 'ECONNABORTED' &&\n    (!error.response || (error.response.status >= 500 && error.response.status <= 599))\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isSafeRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false\n  }\n\n  return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isIdempotentRequestError(error) {\n  if (!error.config) {\n    // Cannot determine if the request can be retried\n    return false\n  }\n\n  return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1\n}\n\n/**\n * @param  {Error}  error\n * @return {boolean}\n */\nexport function isNetworkOrIdempotentRequestError(error) {\n  return isNetworkError(error) || isIdempotentRequestError(error)\n}\n\n/**\n * @return {number} - delay in milliseconds, always 0\n */\nfunction noDelay() {\n  return 0\n}\n\n/**\n * @param  {number} [retryNumber=0]\n * @return {number} - delay in milliseconds\n */\nexport function exponentialDelay(retryNumber = 0) {\n  const delay = Math.pow(2, retryNumber) * 100\n  const randomSum = delay * 0.2 * Math.random() // 0-20% of the delay\n  return delay + randomSum\n}\n\n/**\n * Initializes and returns the retry state for the given request/config\n * @param  {AxiosRequestConfig} config\n * @return {Object}\n */\nfunction getCurrentState(config) {\n  const currentState = config[namespace] || {}\n  currentState.retryCount = currentState.retryCount || 0\n  currentState.requests = currentState.requests || []\n  currentState.cancelled = 'cancelled' in currentState ? currentState.cancelled : false\n  currentState.response = 'response' in currentState ? currentState.response : null\n\n  config[namespace] = currentState\n  return currentState\n}\n\n/**\n * Returns the axios-retry options for the current request\n * @param  {AxiosRequestConfig} config\n * @param  {AxiosRetryConfig} defaultOptions\n * @return {AxiosRetryConfig}\n */\nfunction getRequestOptions(config, defaultOptions) {\n  return Object.assign({}, defaultOptions, config[namespace])\n}\n\n/**\n * @param  {Axios} axios\n * @param  {AxiosRequestConfig} config\n */\nfunction fixConfig(axios, config) {\n  if (axios.defaults.agent === config.agent) {\n    delete config.agent\n  }\n  if (axios.defaults.httpAgent === config.httpAgent) {\n    delete config.httpAgent\n  }\n  if (axios.defaults.httpsAgent === config.httpsAgent) {\n    delete config.httpsAgent\n  }\n}\n\nfunction createCancelToken() {\n  const cancelSource = CancelToken.source()\n  return {\n    cancelSource,\n    cancelToken: cancelSource.token,\n  }\n}\n\nfunction removeCircular(obj) {\n  if (obj) {\n    return JSON.parse(safeStringify(obj))\n  }\n  return obj\n}\n\nfunction cleanupOutput(output) {\n  const keys = Object.keys(output)\n  keys.forEach(key => {\n    output[key] = removeCircular(output[key])\n  })\n  return output\n}\n\n/**\n * Adds response interceptors to an axios instance to retry requests failed due to network issues\n *\n * @example\n *\n * import axios from 'axios';\n *\n * axiosRetry(axios, { retries: 3 });\n *\n * axios.get('http://example.com/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Exponential back-off retry delay between requests\n * axiosRetry(axios, { retryDelay : axiosRetry.exponentialDelay});\n *\n * // Custom retry delay\n * axiosRetry(axios, { retryDelay : (retryCount) => {\n *   return retryCount * 1000;\n * }});\n *\n * // Also works with custom axios instances\n * const client = axios.create({ baseURL: 'http://example.com' });\n * axiosRetry(client, { retries: 3 });\n *\n * client.get('/test') // The first request fails and the second returns 'ok'\n *   .then(result => {\n *     result.data; // 'ok'\n *   });\n *\n * // Allows request-specific configuration\n * client\n *   .get('/test', {\n *     'axios-retry': {\n *       retries: 0\n *     }\n *   })\n *   .catch(error => { // The first request fails\n *     error !== undefined\n *   });\n *\n * @param {Axios} axios An axios instance (the axios object or one created from axios.create)\n * @param {Object} [defaultOptions]\n * @param {number} [defaultOptions.retries=3] Number of retries\n * @param {Function} [defaultOptions.retryCondition=isNetworkOrIdempotentRequestError]\n *        A function to determine if the error can be retried\n * @param {Function} [defaultOptions.retryDelay=noDelay]\n *        A function to determine the delay between retry requests\n * @return {undefined}\n */\nexport default function axiosRetry(axios, defaultOptions) {\n  const cancelAll = (config) => {\n    const currentState = getCurrentState(config)\n\n    currentState.cancelled = true\n\n    const { requests } = currentState\n\n    requests\n      .forEach(request => {\n        request.preventRetryFromTimeout = true\n        request.preventRetryFromError = true\n      })\n\n    if (config.cancelSource) {\n      config.cancelSource.cancel({ config })\n    }\n  }\n\n  const retry = (config) => {\n    const request = axios({\n      ...config,\n    })\n    request.catch(() => {})\n\n    return request\n  }\n\n  axios.interceptors.request.use((config) => {\n    const currentState = getCurrentState(config)\n    currentState.lastRequestTime = Date.now()\n\n    const { retryTimeout, cancelToken } = config\n\n    let curConfig = { ...config }\n\n    if (!cancelToken) {\n      curConfig = {\n        ...curConfig,\n        ...createCancelToken(),\n      }\n    }\n\n    const {\n      qwestLegacy = false,\n    } = getRequestOptions(config, defaultOptions)\n\n    curConfig = {\n      ...curConfig,\n      qwestLegacy,\n      preventRetryFromTimeout: false,\n      preventRetryFromError: false,\n      hasRetriedFromTimeout: false,\n      hasRetriedFromError: false,\n      retryFromTimeout: null,\n    }\n\n    if (retryTimeout) {\n      setTimeout(() => {\n        if (!curConfig.preventRetryFromTimeout) {\n          curConfig.preventRetryFromError = true\n          curConfig.hasRetriedFromTimeout = true\n\n          curConfig.retryFromTimeout = retry({ ...curConfig })\n        }\n      }, retryTimeout)\n    }\n\n    currentState.requests.push(curConfig)\n\n    return curConfig\n  })\n\n  // In case of success\n  axios.interceptors.response.use(response => {\n    const returnValue = Promise.resolve(response)\n\n    const { config } = response\n    if (!config) return returnValue\n\n    const currentState = getCurrentState(config)\n    if (!currentState) return returnValue\n\n    currentState.response = response\n\n    // cancel all pending requests\n    cancelAll(config)\n\n    return returnValue\n  }, error => {\n    // In case of error\n\n    const isCancellation = error.__CANCEL__\n    const config = isCancellation && error.message && error.message.config ? error.message.config : error.config\n\n    // If we have no information to retry the request\n    if (!config) {\n      return Promise.reject(cleanupOutput(error))\n    }\n\n    const currentState = getCurrentState(config)\n\n    if (currentState && currentState.response) {\n      return Promise.resolve(currentState.response)\n    }\n\n    const {\n      retries = 3,\n      retryCondition = isNetworkOrIdempotentRequestError,\n      retryDelay = noDelay,\n      qwestLegacy = false,\n    } = getRequestOptions(config, defaultOptions)\n\n    const retryMeetsCondition = retryCondition(error)\n    const shouldRetry =\n      retryMeetsCondition &&\n      currentState.retryCount < retries &&\n      (!config.hasTimedOut || qwestLegacy) &&\n      !config.preventRetryFromError\n\n    config.preventRetryFromTimeout = true\n\n    if (shouldRetry) {\n      currentState.retryCount++\n      const delay = retryDelay(currentState.retryCount, error)\n\n      // Axios fails merging this configuration to the default configuration because it has an issue\n      // with circular structures: https://github.com/mzabriskie/axios/issues/370\n      fixConfig(axios, config)\n\n      if (!qwestLegacy && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime\n        // Minimum 1ms timeout (passing 0 or less to XHR means no timeout)\n        config.timeout = Math.max((config.timeout - lastRequestDuration) - delay, 1)\n        if (config.timeout === 1) {\n          config.hasTimedOut = true\n        }\n      }\n\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          // retries if it should continue with retrying from error\n          if (!config.preventRetryFromError) {\n            config.hasRetriedFromError = true\n            config.preventRetryFromTimeout = true\n            return retry(config)\n              .then(result => {\n                resolve(result)\n              })\n              .catch(e => {\n                reject(cleanupOutput(e))\n              })\n          } else if (config.hasRetriedFromTimeout) {\n            // if in this meantime (i.e. the delay from retrying from error)\n            // the retry from timeout has been dispatched, return that\n            // instead and avoid retrying\n            return config.retryFromTimeout\n              .then(result => resolve(result))\n              .catch(e => {\n                reject(cleanupOutput(e))\n              })\n          }\n        }, delay)\n      })\n    // if it still can retry, but retry from error has been prevented,\n    // and it has retried from timeout\n    } else if (retryMeetsCondition && !config.hasTimedOut && config.hasRetriedFromTimeout) {\n      return config.retryFromTimeout\n    }\n\n    // reject if can't retry anymore\n    return Promise.reject(cleanupOutput(error))\n  })\n}\n\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError\naxiosRetry.isSafeRequestError = isSafeRequestError\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError\naxiosRetry.exponentialDelay = exponentialDelay\n"]}