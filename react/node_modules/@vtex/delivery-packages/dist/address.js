'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PICKUP = 'pickup';
var GIFT_REGISTRY = 'giftRegistry';

var SEARCH = 'search';

function S4() {
  return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
}

function uuid() {
  return (S4() + S4() + "-" + S4() + "-4" + S4().substr(0, 3) + "-" + S4() + "-" + S4() + S4() + S4()).toLowerCase();
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** PRIVATE **/

function getCleanAddressType(addressType) {
  return addressType && addressType.trim().toLowerCase();
}

function equalsAddressType(addressType1, addressType2) {
  return getCleanAddressType(addressType1) === getCleanAddressType(addressType2);
}

function getFirstAddressForType(addresses, addressType) {
  if (!addresses || addresses.length === 0 || !addressType) {
    return null;
  }

  addressType = getCleanAddressType(addressType);

  var groups = groupByAddressType(addresses);
  var groupAddresses = groups[addressType];
  return groupAddresses && groupAddresses.length > 0 ? groupAddresses[0] : null;
}

function getFirstAddressOnAnyOfTheseTypes(addresses, addressesTypes) {
  return addressesTypes.reduce(function (address, addressType) {
    return address || getFirstAddressForType(addresses, addressType);
  }, null);
}

function getFirstAddressForDelivery(addresses) {
  if (!addresses || addresses.length === 0) {
    return null;
  }

  var deliveryAddresses = addresses.filter(function (address) {
    return isDeliveryAddress(address);
  });

  return deliveryAddresses && deliveryAddresses.length > 0 ? deliveryAddresses[0] : null;
}

function getPickupAddress(pickupSla) {
  return pickupSla && pickupSla.pickupStoreInfo && pickupSla.pickupStoreInfo.address || null;
}

function isCurrentAddressType(address, addressType) {
  if (address && !address.addressType) {
    return false;
  }
  if (address && typeof address.addressType === 'string') {
    return equalsAddressType(address.addressType, addressType);
  }
  return address && equalsAddressType(address.addressType.value, addressType);
}

/** PUBLIC **/

var defaultRequiredAddressFields = ['state', 'city', 'neighborhood', 'street', 'number'];

function isAddressComplete(address) {
  var requiredFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRequiredAddressFields;

  return !!address && requiredFields.every(function (field) {
    return !!address[field];
  });
}

function isGiftRegistry(address) {
  return isCurrentAddressType(address, GIFT_REGISTRY);
}

function isPickupAddress(address) {
  return isCurrentAddressType(address, PICKUP);
}

function isSearchAddress(address) {
  return isCurrentAddressType(address, SEARCH);
}

function isDeliveryAddress(address) {
  if (!address || !address.addressType) {
    return false;
  }

  return !isPickupAddress(address) && !isSearchAddress(address);
}

function addAddressId(address) {
  if (!address || address.addressId) {
    return address;
  }
  return _extends({}, address, {
    addressId: uuid()
  });
}

function findAddressIndex(addresses, searchAddress) {
  var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'addressId';

  if (!addresses || addresses.length === 0 || !searchAddress) {
    return -1;
  }

  return addresses.findIndex(function (address) {
    return address[prop] === searchAddress[prop];
  });
}

function findAddress(addresses, searchAddress) {
  var prop = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'addressId';

  if (!addresses || addresses.length === 0 || !searchAddress) {
    return null;
  }

  return addresses.find(function (address) {
    return address[prop] === searchAddress[prop];
  }) || null;
}

function findAddressByPostalCode(addresses, searchAddress) {
  return findAddress(addresses, searchAddress, 'postalCode');
}

function getDeliveryAvailableAddresses(addresses, requiredFields) {
  if (!addresses || addresses.length === 0) {
    return [];
  }

  return addresses.filter(function (address) {
    return isAddressComplete(address, requiredFields) && isDeliveryAddress(address);
  });
}

function groupByAddressType(addresses) {
  if (!addresses || addresses.length === 0) {
    return {};
  }

  return addresses.reduce(function (groups, address, index) {
    if (address && address.addressType) {
      var addressType = getCleanAddressType(address.addressType);
      address.index = index;
      if (!groups[addressType]) {
        groups[addressType] = [];
      }
      groups[addressType].push(address);
    }
    return groups;
  }, {});
}

function addOrReplaceAddressTypeOnList(addresses, newAddress) {
  if (!addresses || !newAddress) {
    return addresses;
  }

  var newAddresses = [].concat(toConsumableArray(addresses));

  var address = getFirstAddressForType(newAddresses, newAddress.addressType);

  if (!address) {
    return [].concat(toConsumableArray(newAddresses), [newAddress]);
  }

  var addressIndex = address.index;
  newAddresses[addressIndex] = _extends({}, newAddresses[addressIndex], newAddress);

  return newAddresses;
}

function setDeliveryAddressOnList(addresses, newAddress) {
  if (!addresses || !newAddress || isPickupAddress(newAddress)) {
    return addresses;
  }

  var newAddresses = [].concat(toConsumableArray(addresses));

  var address = getFirstAddressForDelivery(newAddresses);

  if (!address) {
    return [].concat(toConsumableArray(newAddresses), [newAddress]);
  }

  var addressIndex = findAddressIndex(newAddresses, address);
  newAddresses[addressIndex] = _extends({}, newAddresses[addressIndex], newAddress);

  return newAddresses;
}

function addOrReplaceAddressOnList(addresses, newAddress) {
  if (!addresses || !newAddress) {
    return addresses;
  }

  var newAddresses = [].concat(toConsumableArray(addresses));

  var addressIndex = findAddressIndex(newAddresses, newAddress);

  if (addressIndex === -1) {
    return [].concat(toConsumableArray(newAddresses), [newAddress]);
  }

  newAddresses[addressIndex] = _extends({}, newAddresses[addressIndex], newAddress);

  return newAddresses;
}

function addPickupPointAddresses(addresses, pickupSlas) {
  if (!addresses || !pickupSlas || pickupSlas.length === 0) {
    return addresses;
  }

  return pickupSlas.reduce(function (newAddresses, pickupSla) {
    var pickupAddress = getPickupAddress(pickupSla);
    var searchAddress = findAddress(addresses, pickupAddress);
    if (searchAddress) {
      return newAddresses;
    }

    var newAddress = _extends({}, pickupAddress, {
      addressType: SEARCH
    });

    return addOrReplaceAddressOnList(newAddresses, newAddress);
  }, [].concat(toConsumableArray(addresses)));
}

exports.equalsAddressType = equalsAddressType;
exports.getFirstAddressForType = getFirstAddressForType;
exports.getFirstAddressOnAnyOfTheseTypes = getFirstAddressOnAnyOfTheseTypes;
exports.getFirstAddressForDelivery = getFirstAddressForDelivery;
exports.getPickupAddress = getPickupAddress;
exports.isCurrentAddressType = isCurrentAddressType;
exports.defaultRequiredAddressFields = defaultRequiredAddressFields;
exports.isAddressComplete = isAddressComplete;
exports.isGiftRegistry = isGiftRegistry;
exports.isPickupAddress = isPickupAddress;
exports.isSearchAddress = isSearchAddress;
exports.isDeliveryAddress = isDeliveryAddress;
exports.addAddressId = addAddressId;
exports.findAddressIndex = findAddressIndex;
exports.findAddress = findAddress;
exports.findAddressByPostalCode = findAddressByPostalCode;
exports.getDeliveryAvailableAddresses = getDeliveryAvailableAddresses;
exports.groupByAddressType = groupByAddressType;
exports.addOrReplaceAddressTypeOnList = addOrReplaceAddressTypeOnList;
exports.setDeliveryAddressOnList = setDeliveryAddressOnList;
exports.addOrReplaceAddressOnList = addOrReplaceAddressOnList;
exports.addPickupPointAddresses = addPickupPointAddresses;
//# sourceMappingURL=address.js.map
