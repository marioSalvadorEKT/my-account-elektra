'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

if (!Array.prototype.findIndex) {
  // eslint-disable-next-line no-extend-native
  Array.prototype.findIndex = function (predicate) {
    if (this === null) {
      throw new TypeError('Array.prototype.findIndex called on null or undefined');
    }
    if (typeof predicate !== 'function') {
      throw new TypeError('predicate must be a function');
    }
    var list = Object(this);
    var length = list.length >>> 0;
    var thisArg = arguments[1];
    var value;

    for (var i = 0; i < length; i++) {
      value = list[i];
      if (predicate.call(thisArg, value, i, list)) {
        return i;
      }
    }
    return -1;
  };
}

if (!Array.prototype.find) {
  // eslint-disable-next-line no-extend-native
  Array.prototype.find = function (predicate) {
    if (this === null) {
      throw new TypeError('Array.prototype.find called on null or undefined');
    }
    if (typeof predicate !== 'function') {
      throw new TypeError('predicate must be a function');
    }
    var list = Object(this);
    var i = list.findIndex(predicate);
    return list[i];
  };
}

if (!Array.isArray) {
  Array.isArray = function (arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** PRIVATE **/

function getItemIndex(item) {
  if (!item) {
    return -1;
  }
  var index = item.index != null ? item.index : item.itemIndex;
  return index != null ? index : -1;
}

/** PUBLIC **/

function getNewItems(items, changes) {
  if (!items || items.length === 0 || !changes || changes.length === 0) {
    return items || null;
  }

  var addedSkusFromChanges = changes.reduce(function (acc, change) {
    return acc.concat(change.itemsAdded || []);
  }, []);

  var removedSkusFromChanges = changes.reduce(function (acc, change) {
    return acc.concat(change.itemsRemoved || []);
  }, []).map(function (item) {
    return _extends({}, item, {
      // Change removedItems to negative quantity so we can sum it later
      quantity: item.quantity * -1
    });
  });

  var itemsChanged = [].concat(toConsumableArray(addedSkusFromChanges), toConsumableArray(removedSkusFromChanges));

  return items.reduce(function (acc, item) {
    var itemChanges = itemsChanged.filter(function (changedItem) {
      return changedItem.id === item.id;
    });

    var newItem = itemChanges.reduce(function (newItem, changedItem) {
      return _extends({}, newItem, {
        quantity: newItem.quantity + changedItem.quantity
      });
    }, item);

    if (newItem.quantity <= 0) return acc;

    return acc.concat(newItem);
  }, []);
}

/* params: { items, packages } */
function getDeliveredItems(params) {
  if (!params || !params.items) {
    return null;
  }

  var items = params.items,
      packages = params.packages;


  var deliveredItems = items.reduce(function (groups, item) {
    var packagesWithItem = packages && packages.filter(function (pack) {
      return pack.items.some(function (packageItem) {
        return packageItem.itemIndex === item.index;
      });
    });

    if (packagesWithItem.length === 0) {
      groups.toBeDelivered = groups.toBeDelivered.concat({
        item: item
      });

      return groups;
    }

    var quantityInPackages = packagesWithItem.reduce(function (total, pack) {
      var packageItem = pack.items.find(function (packageItem) {
        return packageItem.itemIndex === item.index;
      });

      return total + packageItem.quantity;
    }, 0);

    var packageDeliveredAllItems = quantityInPackages === item.quantity;
    var quantityLeftToDeliver = item.quantity - quantityInPackages;

    if (packageDeliveredAllItems === false && quantityLeftToDeliver > 0) {
      groups.toBeDelivered = groups.toBeDelivered.concat({
        item: _extends({}, item, { quantity: quantityLeftToDeliver })
      });
    }
    var delivered = packagesWithItem.map(function (pack) {
      var packageItem = pack.items.find(function (packageItem) {
        return packageItem.itemIndex === item.index;
      });

      return {
        package: pack,
        item: _extends({}, item, { quantity: packageItem.quantity })
      };
    });

    groups.delivered = groups.delivered.concat(delivered);

    return groups;
  }, { delivered: [], toBeDelivered: [] });

  return deliveredItems;
}

function getItemsIndexes(items) {
  var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

  if (!items || items.length === 0) {
    return {
      indexes: [],
      otherIndexes: [],
      indexesMap: {},
      maxIndex: -1
    };
  }

  var indexesMap = {};
  var indexes = [];
  var otherIndexes = [];
  var maxIndex = 0;

  items.forEach(function (item) {
    var itemIndex = getItemIndex(item);
    maxIndex = Math.max(maxIndex, itemIndex);
    if (itemIndex !== -1) {
      indexesMap[itemIndex] = item;
      indexes.push(itemIndex);
    }
  });

  len = Math.max(len, maxIndex);

  for (var index = 0; index < len; index++) {
    if (!indexesMap[index]) {
      otherIndexes.push(index);
    }
  }

  return {
    indexes: indexes,
    otherIndexes: otherIndexes,
    indexesMap: indexesMap,
    maxIndex: maxIndex
  };
}

exports.getItemIndex = getItemIndex;
exports.getNewItems = getNewItems;
exports.getDeliveredItems = getDeliveredItems;
exports.getItemsIndexes = getItemsIndexes;
//# sourceMappingURL=items.js.map
